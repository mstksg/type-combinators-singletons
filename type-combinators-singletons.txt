-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Interop between /type-combinators/ and /singletons/.
--   
--   Conversions between datatypes in <i>type-combinators</i> and
--   singletons from <i>singletons</i> and orphan instances.
@package type-combinators-singletons
@version 0.2.1.0


-- | There's a lot of identical data types between <i>type-combinators</i>
--   and <i>singetons</i>, as well as similar typeclasses. This module
--   provides conversion functions between the two (through the <a>TC</a>
--   typeclass), and also many appropriate orphan instances.
module Data.Type.Combinator.Singletons

-- | Typeclass for <i>type-combinator</i> types that can be converted to
--   and from singletons.
class TC f

-- | Convert a <i>type-combinator</i> type that is equivalent to a
--   singleton into its equivalent <a>Sing</a>.
fromTC :: TC f => f a -> Sing a

-- | Convert a <a>Sing</a> into its equivalent <i>type-combinator</i> type.
toTC :: TC f => Sing a -> f a

-- | Convert a <a>Sing</a> for <tt>as</tt> into a <a>Length</a>
--   representing the length of <tt>as</tt>.
--   
--   <tt><a>Length</a> as</tt> is equivalent to <tt><a>Prod</a>
--   <a>Proxy</a> as</tt>, so this is basically
--   
--   <pre>
--   <a>singLength</a> :: <a>Sing</a> as -&gt; <a>Prod</a> <a>Proxy</a> as
--   <a>singLength</a> = <a>map1</a> (<a>const</a> <a>Proxy</a>) . <a>toTC</a>
--   </pre>
--   
--   This function is one-way, since the actual run-time information on the
--   types in <tt>as</tt> is lost.
singLength :: Sing as -> Length as

-- | Convert <tt><a>SomeSing</a> k</tt> from <i>singletons</i> into the
--   more generic representation <tt><a>Some</a> <a>Sing</a></tt>, from
--   <i>type-combinators</i>.
singSome :: SomeSing k -> Some (Sing :: k -> Type)

-- | Convert the generic representation <tt><a>Some</a> <a>Sing</a></tt>
--   from <i>type-combinatprs</i> to <tt><a>SomeSing</a> k</tt>, from
--   <i>singletons</i>.
someSing :: Some (Sing :: k -> Type) -> SomeSing k

-- | Convert a <tt><a>SingInstance</a> a</tt> from <i>singletons</i> into
--   the more generic representation <tt><a>Wit1</a> <a>SingI</a> a</tt>.
singWit1 :: SingInstance a -> Wit1 SingI a

-- | Convert the generic representation <tt><a>Wit1</a> <tt>SIngI</tt>
--   a</tt> from <i>type-combinators</i> to <tt><a>SingInstance</a> a</tt>
--   from <i>singletons</i>.
wit1Sing :: Wit1 SingI a -> SingInstance a

-- | The singleton kind-indexed data family.
type SN = (Sing :: N -> Type)
type ZSym0 = Z
data SSym0 (l_anhI :: TyFun N N)
type SSym1 (t_anhH :: N) = S t_anhH
instance Data.Type.Combinator.Singletons.TC (Data.Type.Product.Prod Data.Singletons.Internal.Sing)
instance Data.Type.Combinator.Singletons.TC Data.Type.Boolean.Boolean
instance Data.Type.Combinator.Singletons.TC Data.Type.Nat.Nat
instance Data.Type.Combinator.Singletons.TC (Data.Singletons.Internal.Sing Data.Type.Conjunction.:*: Data.Singletons.Internal.Sing)
instance Data.Type.Combinator.Singletons.TC (Data.Singletons.Internal.Sing Data.Type.Disjunction.:+: Data.Singletons.Internal.Sing)
instance Data.Type.Combinator.Singletons.TC (Data.Type.Option.Option Data.Singletons.Internal.Sing)
instance Data.Singletons.SuppressUnusedWarnings.SuppressUnusedWarnings Data.Type.Combinator.Singletons.SSym0
instance Data.Singletons.Internal.SingKind Type.Family.Nat.N
instance Data.Singletons.Internal.SingI 'Type.Family.Nat.Z
instance Data.Singletons.Internal.SingI n => Data.Singletons.Internal.SingI ('Type.Family.Nat.S n)
instance forall k (a :: k). Data.Singletons.Internal.SingI a => Type.Class.Known.Known Data.Singletons.Internal.Sing a
instance forall k (a :: k). Type.Class.Witness.Witness Type.Family.Constraint.Ã˜C (Data.Singletons.Internal.SingI a) (Data.Singletons.Internal.Sing a)
instance Data.Singletons.Prelude.Eq.SEq k => Type.Class.Higher.Eq1 Data.Singletons.Internal.Sing
instance Data.Singletons.Prelude.Ord.SOrd k => Type.Class.Higher.Ord1 Data.Singletons.Internal.Sing
